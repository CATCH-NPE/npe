---
title: "4. IP와 ARP"
description:
date: 2025-10-03
update: 2025-10-03
tags:
  - 네트워크
series: "네트워크"
---

## 데이터 링크 계층의 한계
물리 계층과 데이터 링크 계층만으로 LAN을 넘어서 다른 도시나 다른 국가에 있는 노드와 통신할 수 있을까요? 
언뜻 들으면 가능할 것 같지만, 데이터 링크 계층에는 송수신지를 특정할 수 있는 잘 보인 MAC 주소라는 개념이 있으니까, 
이 정보를 바탕으로 다른 도시, 다른 국가에 있는 수신지로 전송하면 될 것 같습니다.

그러나 결론부터 말하자면 물리 계층과 데이터 링크 계층만으로는 LAN을 넘어서 통신하기 어렵습니다.
대표적으로 두 가지 이유가 있는데, 이 이유는 이번 장에서 학습할 네트워크 계층의 핵심 기능과도 직결됩니다.

첫째, 물리 계층과 데이터 링크 계층만으로는 다른 네트워크까지의 도달 경로를 파악하기 어렵습니다.
물리 계층과 데이터 링크 계층은 기본적으로 LAN을 다루는 계층입니다. 
하지만 LAN에 속한 호스트끼리만 통신하지는 않습니다.
우리의 컴퓨터와 지구 반대편에 있는 사람의 컴퓨터가 정보를 주고받는다면, 
해당 패킷은 서로에게 도달하기까지 수많은 네트워크 장비를 거치며 다양한 경로를 통해 이동하게 될 겁니다.
예를 들어서 LAN A에 속한 호스트가 LAN B에 속한 호스트에게 전송하는 패킷은 다양한 경로를 통해 이동할 수 있습니다. 
통신을 빠르게 주고받으려면 이 중에 최적의 경로로 패킷이 이동해야 합니다. 
이렇게 패킷이 이동할 최적의 경로를 결정하는 것을 라우팅(routing)이라고 합니다.
물리 계층과 데이터 링크 계층의 장비로는 라우팅을 수행할 수 없지만, 네트워크 계층의 장비로는 가능합니다.
라우팅을 수행하는 대표적인 장비로는 라우터(router)가 있습니다.

둘째, MAC 주소만으로는 모든 네트워크에 속한 호스트의 위치를 특정하기 어렵습니다.
현실적으로 모든 호스트가 모든 네트워크에 속한 모든 호스트의 MAC 주소를 서로 알고 있기는 어렵습니다. 
그래서 MAC 주소만으로는 이 세상에 있는 모든 호스트를 특정하기 어렵습니다.
네트워크를 통해 정보를 주고받는 과정은 택배를 송수신하는 과정과 같고, 
MAC 주소는 네트워크 인터페이스(NIC)마다 할당된 일종의 개인 정보와도 같습니다. 
인물을 특정하는 정보 외에 당연히 수신지도 써야 합니다. 
수신지를 쓰지 않는다면 택배 기사 입장에서는 받는 사람이 현재 어디에 살고 있는지 알 수 없기 때문입니다. 
택배를 받는 사람의 위치가 시시각각 변할 수도 있기 때문입니다.
네트워크에서도 마찬가지입니다.
택배의 수신인 역할을 하는 정보가 MAC 주소라면, 
수신지 역할을 하는 정보는 네트워크 계층의 IP 주소입니다. 
택배 배송 과정에서 '수신인'과 '수신지'를 모두 활용하고 '수신인'보다 '수신지'를 우선으로 고려하는 것처럼, 
네트워크에서도 MAC 주소와 IP 주소를 함께 사용하고, 기본적으로 IP 주소를 우선으로 활용합니다.

MAC 주소를 물리 주소라고도 부르는 것처럼 IP 주소는 논리 주소라고도 부릅니다. 
MAC 주소는 일반적으로 NIC마다 할당되는 고정된 주소이지만, IP 주소는 호스트에 직접 할당이 가능합니다.
IP는 DHCP(Dynamic Host Configuration Protocol)라는 특정 프로토콜을 통해 자동으로 할당받거나 사용자가 직접 할당할 수도 있고, 
한 호스트가 복수의 IP 주소를 가질 수도 있습니다.
정리하면,
물리 계층과 데이터 링크 계층만으로는 네트워크 간 통신이 어렵고, 
네트워크 계층이 다른 네트워크와 통신할 수 있도록 해주는 역할을 합니다.
이는 IP 주소를 이용해 수신지 주소를 설정하거나, 
해당 수신지까지의 최적 경로를 결정하는 라우팅이 네트워크 계층에서 이루어지기 때문임을 꼭 기억해야 합니다.

## 인터넷 프로토콜(IP)
네트워크 계층의 가장 핵심적인 프로토콜 하나를 꼽자면 단연 인터넷 프로토콜(IP)입니다. 
IP에는 IP 버전 4(이하 IPv4)와 IP 버전 6(이하 IPv6) 이렇게 두 가지 버전이 존재합니다.
일반적으로 IP 혹은 IP 주소를 이야기할 때는 주로 IPv4를 의미하는 경우가 많습니다.

### IP 주소 형태

IP 주소는 4바이트(32비트)로 주소를 표현할 수 있으며, 
숫자당 8비트로 표현되기에 0255 범위 안에 있는 네 개의 10진수로 표기됩니다.
각 10진수는 점(.)으로 구분되며, 
점으로 구분된 8비트(0255 범위의 10진수)를 옥텟(octet)이라 합니다. 
다음 그림의 192, 168, 1, 1 각각은 8비트로 표현된 옥텟인 셈입니다.

### IP의 기능

IP의 기능은 다양하지만 대표적인 기능은 크게 두 가지입니다. 
IP 주소 지정과 IP 단편화입니다.

IP 주소 지정(IP addressing) : IP 주소를 바탕으로 송수신 대상을 지정하는 것을 의미합니다.
IP 단편화(IP fragmentation) : 전송하고자 하는 패킷의 크기가 MTU라는 최대 전송 단위보다 클 경우, 이를 MTU 크기 이하의 복수의 패킷으로 나누는 것을 의미합니다.

> MTU(Maximum Transmission Unit)
> 한 번에 전송 가능한 IP 패킷의 최대 크기를 의미합니다. 
> 일반적인 MTU 크기는 1500바이트이며, MTU 크기 이하로 나누어진 패킷은 수신지에 도착하면 다시 재조합됩니다.(IP 패킷의 헤더도 MTU 크기에 포함됩니다.)

## IPv4
프레임의 데이터 필드에는 상위 계층에서 전달받거나 상위 계층으로 전달해야 할 내용이 명시된다고 했는데요,
따라서 IPv4 패킷은 프레임의 페이로드로 데이터 필드에 명시됩니다.
모든 필드 중에서도 가장 핵심이 되는 부분인 필드는 ① 식별자, ② 플래그, ③ 단편화 오프셋, ④ TTL, ⑤ 프로토콜, ⑥ 송신지 IP 주소, ⑦ 수신지 IP 주소의 총 7개입니다.
이중에서 식별자, 플래그, 단편화 오프셋 필드는 IP 단편화 기능에 관여하고, 송신지 IP 주소, 수신지 IP 주소는 IP 주소 지정 기능에 관여합니다.

### 식별자

식별자(identifier)는 패킷에 할당된 번호입니다.
만일 메시지 전송 과정에서 IPv4 패킷이 여러 조각으로 쪼개져서 전송되었다면, 수신지에서는 이들을 재조합해야 합니다.
이때, 잘게 쪼개져서 수신지에 도착한 IPv4 패킷들이 어떤 메시지에서부터 쪼개졌는지를 인식하기 위해서 식별자를 사용합니다.

### 플래그

플래그(flag)는 총 세 개의 비트로 구성된 필드입니다.
이 중에서 첫 번째 비트는 항상 0으로 예약된 비트로 현재 사용되지 않습니다.
사용되는 나머지 두 개의 비트 중에서 하나는 DF라는 이름이 붙은 비트입니다.
이는 Don’t Fragment의 약어로, IP 단편화를 수행하지 말라는 표시입니다.
(만일 이 비트가 1로 설정되어 있다면 IP 단편화를 수행하지 않고, 0으로 설정되어 있다면 IP 단편화가 가능합니다.)

또 하나의 비트는 MF라는 비트입니다.
이는 More Fragment의 약어로, 단편화된 패킷이 더 있는지를 나타냅니다.
(0이라면 이 패킷이 마지막 패킷임을 의미하고, 1이라면 쪼개진 패킷이 아직 더 있다는 것을 의미합니다.)

### 단편화 오프셋

단편화 오프셋(fragment offset)은 패킷이 단편화되기 전에 패킷의 초기 데이터에서 몇 번째로 떨어진 패킷인지를 나타냅니다.
단편화되어 전송되는 패킷들은 수신지에 순서대로 도착하지 않을 수 있습니다.
따라서 수신지가 패킷들을 순서대로 재조합하려면 단편화된 패킷이 초기 데이터에서 몇 번째 데이터에 해당하는 패킷인지 알아야 합니다. 
이를 판단하기 위해 단편화 오프셋이 활용됩니다.

### TTL

TTL은 Time To Live의 약어로 패킷의 수명을 의미합니다.
멀리 떨어진 호스트끼리 통신할 때 패킷은 여러 라우터를 거쳐 이동할 수 있습니다.
패킷이 하나의 라우터를 거칠 때마다 TTL이 1씩 감소하며, TTL 값이 0으로 떨어진 패킷은 폐기됩니다.
패킷이 호스트 또는 라우터에 한 번 전달되는 것을 홉(hop)이라고 합니다.
즉, TTL 필드의 값은 홉마다 1씩 감소합니다.
TTL 필드의 존재 이유는 무의미한 패킷이 네트워크상에 지속적으로 남아있는 것을 방지하기 위함입니다.

### 프로토콜

IP 패킷의 프로토콜은 상위 계층의 프로토콜이 무엇인지를 나타내는 필드입니다.
예를 들어서 전송 계층의 대표적인 프로토콜인 TCP는 6번, UDP는 17번입니다.

### 송신지 IP 주소와 수신지 IP 주소

송신지 IP 주소(Source IP Address)와 수신지 IP 주소(Destination IP Address)에서는 이름 그대로 송수신지의 IPv4 주소를 알 수 있습니다.

> 요약하면, IPv4는 식별자, 플래그, 단편화 오프셋으로 단편화와 재조합을 할 수 있고, 
> 프로토콜 필드로 상위 계층 프로토콜을 알 수 있으며, TTL로 패킷의 남은 수명을 파악할 수 있습니다. 
> 또한 송신지 IP 주소, 수신지 IP 주소를 통해 IP 주소를 지정할 수 있습니다.

##  IPv6
IPv4가 이론적으로 할당 가능한 주소의 개수는 약 43억개입니다.
이는 거의 소진되었으며, 이를 대체할 수 있는 프로토콜이 IPv6입니다.
IPv6 주소는 16바이트(128비트)로 주소를 표현할 수 있고, 콜론(:)으로 구분된 8개 그룹의 16진수로 표기됩니다.
다시 말해, 할당 가능한 IPv6 주소는 이론적으로 2^128제곱 개로 사실상 무한에 가까운 개수를 할당할 수 있습니다.

## ARP
택배를 전송할 때 송신지 주소와 수신지, 수신지 주소와 수신지를 함께 명시하되 수신자보다는 수신지를 우선으로 고려하는 것처럼, 
MAC 주소와 IP 주소는 함께 사용하지만 기본적으로는 IP 주소를 사용한다고 했습니다.
이 과정에서 '상대 호스트의 IP 주소는 알지만, MAC 주소는 알지 못하는 상황'이 있을 수 있습니다. 
이럴 때 ARP라는 프로토콜을 사용합니다.
ARP(Address Resolution Protocol)는 IP 주소를 통해 MAC 주소를 알아내는 프로토콜입니다.
동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아낼 수 있습니다.

호스트 A와 B가 모두 동일한 네트워크에 속한 상태에서 A가 B에게 패킷을 보내고 싶다고 가정해봅시다.
A는 B의 IP주소(10.0.02)를 알고 있지만, MAC주소는 모르는 상황입니다.
네트워크에서 기본적으로 사용되는 주소는 IP 주소이지만, 패킷을 올바르게 송신하려면 상대 호스트의 MAC 주소까지 알아야 합니다.
하지만 현재 A는 B의 MAC 주소를 알지 못합니다.
여기서 ARP가 사용된다. ARP의 동작 과정은 다음과 같습니다.

1. ARP 요청
2. ARP 응답
3. ARP 테이블 갱신

### ARP 요청

우선 A는 네트워크 내의 모든 호스트에게 브로드캐스트 메시지를 보냅다.
이 메시지는 ARP 요청(ARP Request)이라는 ARP 패킷입니다.
ARP 요청은 “저 10.0.0.2와 통신하고 싶은데, 이 분의 MAC 주소가 무엇인가요?”라고 소리치는 것과 같습니다.

### ARP 응답

네트워크 내의 모든 호스트가 ARP 요청 메시지를 수신하지만, B를 제외한 나머지 호스트는 자신의 IP 주소가 아니므로 이를 무시합니다.
B는 자신의 MAC 주소를 담은 메시지를 A에게 전송합니다.
이 유니캐스트 메시지는 ARP 응답(ARP Reply)이라는 ARP 패킷입니다.
B의 MAC 주소가 포함된 메시지를 수신한 A는 B의 MAC 주소를 알게 됩니다. (※ 유니캐스트는 하나의 수신지에 메시지를 전송하는 방식입니다.)

### ARP 테이블 갱신

ARP를 활용할 수 있는 모든 호스트는 ARP 테이블(ARP Table)이라는 정보를 유지합니다.
ARP 테이블은 IP 주소와 그에 맞는 MAC 주소 테이블을 대응하는 표입니다.
A는 B의 MAC 주소를 알게 되면 다음 그림처럼 호스트 B의 IP 주소와 MAC 주소의 연관 관계를 ARP 테이블에 추가합니다.
이 ARP 테이블은 일정 시간이 지나면 삭제되고, 임의로 삭제할 수도 있습니다.
여기까지 이루어진다면 앞으로 A는 B와 통신할 때 굳이 브로드캐스트로 ARP 요청을 보낼 필요가 없어지게 됩니다.

> 호스트 A와 호스트 B가 동일한 네트워크에 있지 않다면?
> 호스트 A가 라우터 A의 MAC 주소를 모른다면 ARP 요청 - ARP 응답 과정을 통해 라우터 A의 MAC 주소를 얻어와서 이를 향해 패킷을 전송합니다.
> 호스트 A에서 패킷을 전달받은 라우터 A는 패킷을 라우터 B로 전달해야 합니다. 
> 만일 라우터 A가 라우터 B의 MAC 주소를 모른다면 한 번 더 ARP 요청 – ARP 응답 과정을 거쳐 라우터 B의 MAC 주소를 얻어오게 됩니다.
> 이제 라우터 B는 호스트 B에게 패킷을 전달해야 한다. 
> 만일 라우터 B가 호스트 B의 MAC 주소를 모른다면 똑같이 ARP 요청 – ARP 응답 과정을 통해 B의 MAC 주소를 얻어와야만 비로소 호스트 B에게 패킷을 전달할 수 있다.

## IP 단편화를 피하는 방법
IP 단편화는 되도록 하지 않는 것이 좋습니다.

데이터가 여러 패킷으로 쪼개지면 자연스레 전송해야 할 패킷의 헤더들도 많아지고,
이는 불필요한 트래픽 증가와 대역폭 낭비로 이어질 수 있기 때문입니다.
쪼개진 IP 패킷들을 하나로 합치는 과정에서 발생하는 부하도 성능 저하를 야기할 수 있습니다.
따라서 IP 단편화는 가급적 피하는 것이 좋습니다.


그렇다면 IP 단편화는 어떻게 피할 수 있을까요?
IP 패킷을 주고받는 모든 호스트의 ‘처리 가능한 MTU 크기’를 고려해야 합니다.
가령 호스트 A, B가 여러 라우터를 거쳐 서로 IP 패킷을 주고받는다고 가정해봅시다.
호스트 A, B가 처리할 수 있는 MTU 크기가 아무리 커도 라우터가 해당 MTU 크기를 지원하지 않으면 IP 단편화를 해야 합니다.
따라서 IP 단편화를 피하려면 IP 단편화 없이 주고받을 수 있는 최대 크기만큼만 전송해야 합니다.
이 크기를 경로 MTU(Path MTU)라고 합니다.
다시 말해 IP 단편화를 피하는 방법은 경로 MTU만큼 데이터를 전송하는 것입니다.
경로 MTU를 구하고 해당 크기만큼만 송수신하여 IP 단편화를 회피하는 기술을 경로 MTU 발견(Path MTU discovery)이라 합니다.

오늘날 네트워크에서는 대부분 이를 지원하고,처리 가능한 최대 MTU 크기도 대부분 균일하기 때문에 IP 단편화는 자주 수행되지 않는다.