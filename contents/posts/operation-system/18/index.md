---
title: "상호배제와 동기화 기법"
description: "상호배제와 동기화 기법"
date: 2025-09-20
update: 2025-09-20
tags:
  - 운영체제
series: "프로세스 동기화"
---

## 상호배제(Mutual Exclusion)

---

상호배제(Mutual Exclusion)는 여러 프로세스나 스레드가 동시에 같은 공유 자원에 접근하는 것을 막는 메커니즘입니다.

일상생활에서 비유하면, 화장실 사용과 같습니다.
한 번에 한 사람만 화장실을 사용할 수 있고, 다른 사람들은 기다려야 합니다.
컴퓨터 시스템에서도 마찬가지로 특정 자원은 한 번에 하나의 프로세스만 사용할 수 있어야 합니다.

<br>

## 왜 상호배제가 필요할까?
현대 운영체제는 멀티태스킹 환경에서 여러 프로세스가 동시에 실행됩니다.
이때 프로세스들이 공유하는 자원(메모리, 파일, 데이터베이스 등)에 동시에 접근하면 다음과 같은 문제가 발생할 수 있습니다.

### 1.경쟁 상황(Race Condition)

두 프로세스가 동시에 같은 데이터를 수정하려 할 때, 실행 순서에 따라 결과가 달라지는 상황입니다.
예를 들어, 은행 계좌 잔액을 동시에 업데이트하는 두 거래가 있다면, 최종 잔액이 예상과 다를 수 있습니다.

### 2. 데이터 일관성 파괴

여러 프로세스가 동시에 데이터를 수정하면 데이터의 무결성이 깨질 수 있습니다. 이는 시스템 전체의 신뢰성에 큰 영향을 미칩니다.

<br>
<br>

## 동기화 기법

---

이런 **상호 배제**에 대해 방지하는 방법으로는 **뮤텍스**, **세마포어**, **모니터** 기법이 있습니다.

<br>
<br>

## 뮤텍스 락(Mutex lock)

---

**뮤텍스 락**의 풀네임은 **Mutual Exclusion Lock**입니다. 즉 상호 배제 단어에 lock을 붙인 단어와 일치합니다.

이 말은 상호배제를 구현하기 위해 **Locking**방식을 사용하는 방법입니다.

**뮤텍스 락**은 흔히 화장실 사용에 비유해보겠습니다.

![img.png](toilet.png)

<br>

화장실은 한칸에 한사람만 받을 수 있습니다. 칸에 사람이 들어가있다면 해당 칸에 다른 사람이 들어올 수 없습니다.
다른 사람이 들어오는 시점은 먼저 사용하던 사람이 해당 칸을 나가게 되면 사용할 수 있습니다.

이 내용을 설명하는 이유는, 위 방식의 흐름이 뮤텍스 락과 동일하기 때문입니다.

간단한 **뮤텍스락**을 코드를 통해서 보겠습니다.

**자물쇠**에 해당하는 전역변수 하나, 그리고 해당 **자물쇠**를 잠구고, 푸는 두가지 함수만 있으면 구현가능합니다.

<br>
<br>

````java
acquire(){
    while (lock == true){
        .....
        }
    
    lock = true;
}
````

````java
release(){
    lock = false;
        }
````

<br>

해당 함수들은 차례대로 화장실 문이 잠겼는지 확인하고 잠기지 않았다면 들어가서 잠구는 함수 **Acquire**,
그리고 화장실을 나올때 잠금을 해제 하는 **Release**로 볼 수 있습니다.

이 함수를 아래 수도코드 처럼, 임계 구역 들어가기전, 나온 후 에 사용하게 되면

````java
acquire();
// 임계 구역
release();
````

**lock**여부를 확인 한 후, 들어가도 되면 본인이 **lock**을 걸고 이미 **lock**이 걸려있다면
임계 구역 코드 전에서 계속 기다리게 됩니다.

<br>

### 뮤텍스 락의 단점


하지만, 이런 방식에는 큰 문제가 있는데 **바쁜대기(Busy Wait)** 을 수행하게 됩니다.
명칭 그대로 대기를 하는 상황임에도 바쁘게 행동하는 것을 말하게 됩니다.

**대기**를 하는 상황에 행동을 하는것은 **lock 확인**작업에 **CPU**를 사용하겠다는 것을 의미하고,
이런 기다림은 해당 **lock** 이 풀릴떄까지 지속됩니다. 즉, 비효율적입니다.

<br>
<br>

## 세마포(semaphore)

---

**세마포**는 동기화 방식중 하나입니다. **뮤텍스 락**과 비교하면 공유자원의 갯수를 다루는 방식이 다릅니다.
**뮤텍스 락**은 공유자원이 하나라고 가정하고 라킹을 수행하지만, **세마포**는 공유 자원이 여러 개 있을경우
각 프로세스는 해당 공유자원에 접근이 가능합니다.

마치 공중화장실에서 화장신 칸 수 만큼 공유자원이 있고, 각 칸에 사람이 들어가는 것을 관리하는 방식입니다.

![img.png](semaphore.png)

**세마포**는 사진과 같은 **철도 신호기**에서 유래한 단어 입니다. 그렇기 때문에 철도 신호와 같은 방식을 사용합니다.

**뮤텍스 락**은 공유 자원을 **잠금**, **해제**를 수행하면서 해당 자원을 관리하지만,

**세마포**의 경우 **빨간불**, **초록불** 처럼 가도 되는지, 멈춰야 하는지 상태를 알려줍니다.

**세마포**도 간단하게 코드로 구현이 가능합니다.

먼저 **공유자원의 갯수**를 나타내는 전역 변수 한개와, 임계구역에 들어가도 되는지, 기다려야 할지 알려주는 함수 **Wait**,
그리고 기다리고 있는 프로세스에게 **이제 출발하라**를 나타내는 **Signal**함수가 있습니다.

<br>

````java
wait() {
    while(S <= 0){
        
        }
    S--;
}
````

````java
signal() {
    S++;
}
````

위 코드를 차례대로 **Wait**, **Signal**함수를 구현한것이고 전역 변수 S의 값이 양수, 즉 사용해도 되는
공유자원이 있을 경우 **Wait**함수의 while문을 탈출합니다.

그 경우 사용가능한 공유 자원 갯수를 하나 줄입니다.

````java
wait();
// 임계 구역
signal();
````

임계 구역을 나오게 되면 signal이 수행될것이고, 사용가능한 자원을 하나 반납하게 될것입니다.

<br>

근데 while문이 있다면 **뮤텍스락**처럼  **바쁜 대기** 상태가 발생할 수 있다는걸 암시하게 됩니다.
하지만 이는 세마포가 **CPU**를 사용하지 않게 구현하며 해결할 수 있습니다.

<br>

## 세마포가 busy wait를 해결하는 방법

---

아래 두가지 함수를 통해서 세마포는 **busy wait**를 해결합니다.

````java
wait(){
    S--;
    if ( S < 0){
        add this process to Queue;
        sleep();
    }
}
````

````java
signal(){
    S++
    if ( S <= 0){
        remove a process p from Queue;
        wakeup(p);
        }        
}
````
위 방식은 이전처럼 while문을 통한 접근 가능여부를 체크하는 것이 아닌 만약 접근 불가능 한경우(사용가능한 공유 자원이 없을떄)
해당 프로세스의 **PCB**를 **세마포**를 위한 **대기 큐**에 넣습니다.

프로세스는 대기 큐에 들어가게 되면서 이후 해당 **PCB**를 **준비 큐**로 돌리기 전까지 **CPU**자원을 잡아 먹지 않게 됩니다.







