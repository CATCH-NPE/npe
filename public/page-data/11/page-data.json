{"componentChunkName":"component---src-templates-post-jsx","path":"/11/","result":{"data":{"site":{"siteMetadata":{"title":"CATCH NPE"}},"markdownRemark":{"id":"6b2d0bc1-f501-5533-becc-2e0d0340e9e6","excerpt":"동시성 이슈란? img.png 동시성 이슈란 하나의 자원에 대해 여러 스레드가 접근할때 발생합니다. 예를 들어, 좋아요가 10 인 자원에 대해 스레드 a와 b가 동시에 접근해서 좋아요 10에 대한 값을 가져옵니다.\n스레드 a는 좋아요 카운트를 하나 늘리는 행위를 하고 스레드 b는 좋아요 카운트를 하나 줄이는 행위를 할때\n스레드 a가 좋아요 카운트를 늘리면…","html":"<h2 id=\"동시성-이슈란\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88%EB%9E%80\" aria-label=\"동시성 이슈란 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>동시성 이슈란?</h2>\n<hr>\n<br>\n<p><img src=\"%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4%EC%8A%88.png\" alt=\"img.png\"></p>\n<br>\n<p>동시성 이슈란 하나의 자원에 대해 여러 스레드가 접근할때 발생합니다.</p>\n<p>예를 들어, 좋아요가 10 인 자원에 대해 스레드 a와 b가 동시에 접근해서 좋아요 10에 대한 값을 가져옵니다.\n스레드 a는 좋아요 카운트를 하나 늘리는 행위를 하고 스레드 b는 좋아요 카운트를 하나 줄이는 행위를 할때\n스레드 a가 좋아요 카운트를 늘리면 11가 됩니다. 하지만 스레드 a와 b는 좋아요 카운트에 동시에 접근해서 초기값 10을 받은 상태라면\n스레드 b는 늘어난 11라는 숫자대신 10을 기준으로 값을 줄이게 됩니다. 그럼 최종 결과는 10이 아닌 9라는 값으로 나오게 됩니다.</p>\n<p>이처럼 멀티 스레드 환경에서는 하나의 자원에 동시에 접근하게 되면 이러한 문제가 발생할 수 있다.</p>\n<br>\n<br>\n<h2 id=\"스레드-안전\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%95%88%EC%A0%84\" aria-label=\"스레드 안전 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>스레드 안전</h2>\n<hr>\n<p>그럼 우리가 추구해야 할 문제는 스레드 안전한 멀티 스레드 프로그래밍을 구현할 수 있어야 한다. 이것을 구현하는\n방법에 대해 이야기 하려고 한다.</p>\n<br>\n<br>\n<h2 id=\"스레드-안전-여부-판단\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%95%88%EC%A0%84-%EC%97%AC%EB%B6%80-%ED%8C%90%EB%8B%A8\" aria-label=\"스레드 안전 여부 판단 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>스레드 안전 여부 판단</h2>\n<hr>\n<ol>\n<li>전역 변수나 힙, 파일과 같이 여러 스레드가 동시 접근 가능한 자원을 사용하는가</li>\n<li>핸들과 포인터를 통한 데이터의 간접 접근이 가능한가?</li>\n<li>부수 효과를 가져오는 코드가 있는가?</li>\n</ol>\n<br>\n<br>\n<h2 id=\"스레드-안전을-지키기-위한-4가지-방법\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%95%88%EC%A0%84%EC%9D%84-%EC%A7%80%ED%82%A4%EA%B8%B0-%EC%9C%84%ED%95%9C-4%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95\" aria-label=\"스레드 안전을 지키기 위한 4가지 방법 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>스레드 안전을 지키기 위한 4가지 방법</h2>\n<hr>\n<ol>\n<li>상호 배제(Mutual Exclusion)</li>\n</ol>\n<br>\n<ul>\n<li>공유 자원에 하나의 Thread만 접근할 수 있도록 세마포어/ 뮤텍스락을 통제하는 방법이다.</li>\n</ul>\n<br>\n<ol start=\"2\">\n<li>원자 연산(Atomic Operation)</li>\n</ol>\n<br>\n<ul>\n<li>공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 접근 방법을 사용함으로써 상호 배제를 구현하는 방법이다.</li>\n<li>Atomic\n<ul>\n<li>공유 자원 변경에 필요한 연산을 원자적으로 분리한 뒤에 실제로 데이터의 변경이 이루어지는 시점에 Lock을 걸고,</li>\n</ul>\n데이터를 변경하는 시간 동안 다른 쓰레드의 접근이 불가능하도록 하는 방법이다.</li>\n</ul>\n<br>\n<ol start=\"3\">\n<li>Thread-Local Storage (스레드 지역 저장소)</li>\n</ol>\n<br>\n<ul>\n<li>공유 자원의 사용을 최대한 줄이고 각가의 쓰레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는 방법이다.</li>\n<li>일반적으로 공유 상태를 피할 수 없을 때 사용하는 방식이며, 전역 변수 사용을 자제하라는 뜻으로 생각하면 된다.</li>\n</ul>\n<br>\n<ol start=\"4\">\n<li>Re-entrancy (재진입성)</li>\n</ol>\n<br>\n<ul>\n<li>쓰레드 호출과 상관 없이 프로그램에 문제가 없도록 작성하는 방법이다.</li>\n<li>어떤 함수가 한 스레드에 의해 호출되어 실행 중이라면 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 옳바르게 주어져야 한다.</li>\n<li>쓰레드끼리 독립적으로 동작할 수 있도록 코드를 작성하는 것으로 생각하면 된다.</li>\n</ul>\n<br>\n<br>","frontmatter":{"title":"11. 멀티 쓰레드 프로그래밍의 동시성 이슈와 Thread-Safe 설계 방법","date":"September 14, 2025","update":"September 14, 2025","tags":["운영체제"],"series":"프로세스와 쓰레드에 대해서 알아보기"},"fields":{"slug":"/11/","readingTime":{"minutes":4.365}}},"seriesList":{"edges":[{"node":{"id":"260ee945-dda8-544a-907f-08886cb18912","fields":{"slug":"/7/"},"frontmatter":{"title":"7. 프로세스와 PCB 그리고 메모리 구조에 대해서 알아보기"}}},{"node":{"id":"b775e483-4005-578f-8b56-bc4cf3f18a77","fields":{"slug":"/8/"},"frontmatter":{"title":"8. 문맥교환 그리고 프로세스 상태 변화, 프로세스 계층과 생성 방식을 알아보기"}}},{"node":{"id":"c2d81bbc-3b4c-5c89-b193-1807200e7f30","fields":{"slug":"/9/"},"frontmatter":{"title":"9. 쓰레드의 개념, 메모리 공유 구조 및 TCB"}}},{"node":{"id":"2e4f9ff2-e2bf-57e3-aaad-7eb2f7fd16b2","fields":{"slug":"/10/"},"frontmatter":{"title":"10. 멀티 프로세스와 멀티 쓰레드의 차이 및 장단점"}}},{"node":{"id":"6b2d0bc1-f501-5533-becc-2e0d0340e9e6","fields":{"slug":"/11/"},"frontmatter":{"title":"11. 멀티 쓰레드 프로그래밍의 동시성 이슈와 Thread-Safe 설계 방법"}}}]},"previous":{"fields":{"slug":"/10/"},"frontmatter":{"title":"10. 멀티 프로세스와 멀티 쓰레드의 차이 및 장단점"}},"next":null},"pageContext":{"id":"6b2d0bc1-f501-5533-becc-2e0d0340e9e6","series":"프로세스와 쓰레드에 대해서 알아보기","previousPostId":"2e4f9ff2-e2bf-57e3-aaad-7eb2f7fd16b2","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}