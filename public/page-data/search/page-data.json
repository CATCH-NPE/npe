{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"동시성 이슈란?  동시성 이슈란 하나의 자원에 대해 여러 스레드가 접근할때 발생합니다. 예를 들어, 좋아요가 10 인 자원에 대해 스레드 a와 b가 동시에 접근해서 좋아요 10에 대한 값을 가져옵니다.\n스레드 a는 좋아요 카운트를 하나 늘리는 행위를 하고 스레드 b는 좋아요 카운트를 하나 줄이는 행위를 할때\n스레드 a가 좋아요 카운트를 늘리면 11가 됩니…","fields":{"slug":"/11/"},"frontmatter":{"date":"September 14, 2025","title":"11. 멀티 쓰레드 프로그래밍의 동시성 이슈와 Thread-Safe 설계 방법","tags":["운영체제"]},"rawMarkdownBody":"\n\n## 동시성 이슈란?\n\n---\n\n<br>\n\n![img.png](동시성이슈.png)\n\n<br>\n\n동시성 이슈란 하나의 자원에 대해 여러 스레드가 접근할때 발생합니다.\n\n예를 들어, 좋아요가 10 인 자원에 대해 스레드 a와 b가 동시에 접근해서 좋아요 10에 대한 값을 가져옵니다.\n스레드 a는 좋아요 카운트를 하나 늘리는 행위를 하고 스레드 b는 좋아요 카운트를 하나 줄이는 행위를 할때\n스레드 a가 좋아요 카운트를 늘리면 11가 됩니다. 하지만 스레드 a와 b는 좋아요 카운트에 동시에 접근해서 초기값 10을 받은 상태라면\n스레드 b는 늘어난 11라는 숫자대신 10을 기준으로 값을 줄이게 됩니다. 그럼 최종 결과는 10이 아닌 9라는 값으로 나오게 됩니다.\n\n이처럼 멀티 스레드 환경에서는 하나의 자원에 동시에 접근하게 되면 이러한 문제가 발생할 수 있다.\n\n<br>\n<br>\n\n## 스레드 안전\n\n---\n\n그럼 우리가 추구해야 할 문제는 스레드 안전한 멀티 스레드 프로그래밍을 구현할 수 있어야 한다. 이것을 구현하는\n방법에 대해 이야기 하려고 한다.\n\n<br>\n<br>\n\n## 스레드 안전 여부 판단\n\n---\n\n1. 전역 변수나 힙, 파일과 같이 여러 스레드가 동시 접근 가능한 자원을 사용하는가\n2. 핸들과 포인터를 통한 데이터의 간접 접근이 가능한가?\n3. 부수 효과를 가져오는 코드가 있는가?\n\n<br>\n<br>\n\n## 스레드 안전을 지키기 위한 4가지 방법\n\n---\n\n1. 상호 배제(Mutual Exclusion)\n\n<br>\n\n- 공유 자원에 하나의 Thread만 접근할 수 있도록 세마포어/ 뮤텍스락을 통제하는 방법이다.\n\n<br>\n\n2. 원자 연산(Atomic Operation)\n\n<br>\n\n- 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 접근 방법을 사용함으로써 상호 배제를 구현하는 방법이다.\n- Atomic\n  - 공유 자원 변경에 필요한 연산을 원자적으로 분리한 뒤에 실제로 데이터의 변경이 이루어지는 시점에 Lock을 걸고, \n  데이터를 변경하는 시간 동안 다른 쓰레드의 접근이 불가능하도록 하는 방법이다.\n\n<br>\n\n3. Thread-Local Storage (스레드 지역 저장소)\n\n<br>\n\n- 공유 자원의 사용을 최대한 줄이고 각가의 쓰레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는 방법이다.\n- 일반적으로 공유 상태를 피할 수 없을 때 사용하는 방식이며, 전역 변수 사용을 자제하라는 뜻으로 생각하면 된다.\n\n<br>\n\n4. Re-entrancy (재진입성)\n\n<br>\n\n- 쓰레드 호출과 상관 없이 프로그램에 문제가 없도록 작성하는 방법이다.\n- 어떤 함수가 한 스레드에 의해 호출되어 실행 중이라면 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 옳바르게 주어져야 한다.\n- 쓰레드끼리 독립적으로 동작할 수 있도록 코드를 작성하는 것으로 생각하면 된다.\n\n<br>\n<br>\n\n\n\n\n"},{"excerpt":"멀티 프로세스는 운영체제에서 하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 실행할 수 있게 하는 기술이다.\n보통은 하나의 프로그램을 실행하기 위해서 하나의 프로세스만 메모리에 생성하게 되지만, 부가적인 기능을 위해\n여러개의 프로세스를 생성하는 것이다. 어떻게 멀티 프로세스를 생성할까? 멀티 프로세스는 이전에 보았던 계층구조 프로세스 처럼 부모 …","fields":{"slug":"/10/"},"frontmatter":{"date":"September 13, 2025","title":"10. 멀티 프로세스와 멀티 쓰레드의 차이 및 장단점","tags":["운영체제"]},"rawMarkdownBody":"\n![img.png](멀티프로세스.png)\n\n멀티 프로세스는 운영체제에서 하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 실행할 수 있게 하는 기술이다.\n보통은 하나의 프로그램을 실행하기 위해서 하나의 프로세스만 메모리에 생성하게 되지만, 부가적인 기능을 위해\n여러개의 프로세스를 생성하는 것이다.\n\n<br>\n<br>\n\n### 어떻게 멀티 프로세스를 생성할까?\n\n멀티 프로세스는 이전에 보았던 계층구조 프로세스 처럼 부모 프로세스가\n여러개의 자식 프로세스를 생성한다.\n\n부모 프로세스는 자식 프로세스의 PID를 알고있으며 자식또한 PID와 PPID를 알고있어\n서로 통신이 가능하다.\n\n이런 성질은 각각 독립적이지만 통신이 가능하게 만들었고 멀티 프로세스의 대표적인 예가\n브라우저의 탭이라고 할 수 있다.\n\n브라우저 탭은 문제가 발생해서 닫아야 하는 상황이여도 다른 탭까지 닫히지 않고 개별적으로\n운용을 할 수 있는걸 기억해보면 독립적이란 말을 더 잘 이해할 수 있을것이다.\n\n<br>\n<br>\n\n## 멀티 프로세스의 장점\n\n<br>\n\n1. 안정성\n\n멀티 프로세스의 안정성은 각각의 프로세스가 독립적이기 떄문에 가능하다.\n대표적인 예로 좀전에 설명을 했던 특정 브라우저 탭이 문제가 발생하여 닫아야 하는 상황에서\n같은 브라우저의 다른 탭까지 닫히지는 않는다.\n이런것이 독립적인 성격에 의한 안정성이라고 할 수 있다.\n\n<br>\n<br>\n\n## 멀티 프로세스의 단점\n\n<br>\n\n1. 문맥교환 (Context Switching) Overhead\n\n멀티 태스킹을 이루는 기술인 문맥 교환 과정에서 성능 저하가 발생할 수 있다.\n프로세스를 컨텍스트 스위칭 하면, CPU는 다음 프로세스의 정보를 불러오기 위해\n메모리를 검색하고, CPU 캐시 메모리를 초기화하며, 프로세스 상태를 저장하고, \n불러올 데이터를 준비해야 하기 떄문에, 빈번한 문맥교환이 발생하고 이 비용은 곧 오버헤드로 발생할 수 있다.\n\n<br>\n<br>\n\n2. 자원 공유 비효율성\n\n프로세스는 독립적인 메모리를 가지고, 멀티 프로세스는 독립적인 메모리 공간의 합일 것이다.\n그렇기 때문에 메모리 비효율성을 초래한다.\n\n<br>\n<br>\n\n## 멀티 스레드\n\n---\n\n![img.png](멀티스레드.png)\n\n<br>\n\n이전에 보았던 것처럼 스레드는 하나의 프로세스 내에 있는 실행 흐름이다.\n멀티 스레드는 하나의 프로세스 안에 여러개의 실행흐름을 가지는 것이다.\n멀티 스레드 또한 멀티 프로세스 처럼 여러개의 작업을 동시 실행 할 수 있다.\n\n이전에 보았던 것처럼 멀티 프로세스는 브라우저의 여러개의 탭을 통해 예시를 들었다.\n하지만, 멀티 스레드는 같은 브라우저라 할지라도 동일탭에 여러 실행 흐름을 말하게 되고 \n예를들어 네트워크 처리 스레드, 검색 스레드 와 같이 동일한 프로세스 내 기능들을 말하게 된다.\n\n<br>\n<br>\n\n## 멀티 스레드의 장점\n\n---\n\n### 프로세스보다 스레드가 가벼움\n\n스레드는 프로세스보다 용량이 가볍다. 이유는 데이터, 코드, 힙 영역을\n프로세스와 공유해서 사용하기 때문에 내장된 정보다 프로세스보다 작기 떄문이다.\n그렇기 때문에 스레드를 제거하는 작업이 프로세스를 제거하는 작업보다 가볍다.\n\n<br>\n<br>\n\n### 자원의 효율성\n\n멀티 스레드는 하나의 프로세스 내에서 스택영역을 제외한 영역을 공유하기 때문에\n프로세스 간 통신을 사용하지 않고도 자원의 공유가 가능하여 자원을 효율적으로 사용할 수 있다.\n\n<br>\n<br>\n\n### Context Switching 비용 감소\n\n스레드 문맥 교환 또한 오버헤드가 존재하지만, 프로세스 문맥교환과 비교했을 때,\n상대적으로 오버헤드가 적다.\n\n이유는 프로세스 컨텍스트 스위칭 비용은 스위칭할 때마다 CPU 캐시에 있는 내용을 모두 초기화하고,\n새로운 프로세스 정보를 CPU 캐시에 적재해야 하기 떄문이다.\n하지만, 스레드 문맥교환은 스레드 개별적인 정보만 교체하면 되기 떄문에 비용이 상대적으로 낮다.\n\n<br>\n<br>\n\n## 멀티 스레드의 단점\n\n멀티 프로세스는 개별적인 작업으로 인해 독집적이고, 각자의 문제를 전파하지 않는다고 하였다.\n\n하지만, 멀티 스레드는 하나의 스레드가 문제가 발생하면 다른 스레드들고 영향을 받아 전체가 종료가 될 수 있다.\n\n<br>\n<br>\n\n## 데드락\n\n데드락이란 하나의 자원을 사용하기위해 여러 곳에서 접근했고, 그상황에서 교착상태가 일어났을때\n여러대의 스레드가 서로 대기하면서 무한정 기다리는 현상을 데드락이라고 한다.\n\n예를들어, 스레드 1 은 자원 A을 점유하고 있는 상태에서 자원 B가 필요한 상황이다. \n그리고 스레드 2 는 자원 B를 점유하고 있는 상태에서 자원 A이 필요한 상황이다. \n하지만 스레드 1은 자원 B가 필요한 상황에서 자원 A을 빌려줄 수 있는 상황이 아니고, \n스레드 2또한 자원 A이 필요한 상태에서 자원 B를 빌려줄 수 없는 상황인 것이다.\n이처럼 다수의 쓰레드가 같은 lock을 동시에, \n다른 명령에 의해 획득하려 할 때 서로 절대 불가능한 일을 계속적으로 기다리는 상황을 이야기 한다.\n\n\n\n"},{"excerpt":"스레드란?  스레드는 프로세스를 구성하는 실행의 흐름 단위라고 표현합니다. 또한, 하나의 프로세스가 복수적인 스레드를 가질 수 있습니다. 그렇기 때문에 스레드를 이용하면\n하나의 프로세스에서 여러 부분을 동시에 실행할 수 있습니다. 마치 화상 회의를 진행중에 회의 어플리케이션이란 프로세스 속 채팅과 화상통화의 기능이 독립적으로 돌아가는것과\n같이 여러 기능을…","fields":{"slug":"/9/"},"frontmatter":{"date":"September 12, 2025","title":"9. 쓰레드의 개념, 메모리 공유 구조 및 TCB","tags":["운영체제"]},"rawMarkdownBody":"\n## 스레드란?\n\n---\n\n![img.png](스레드.png)\n\n<br>\n\n스레드는 프로세스를 구성하는 실행의 흐름 단위라고 표현합니다.\n\n또한, 하나의 프로세스가 복수적인 스레드를 가질 수 있습니다. 그렇기 때문에 스레드를 이용하면\n하나의 프로세스에서 여러 부분을 동시에 실행할 수 있습니다.\n\n마치 화상 회의를 진행중에 회의 어플리케이션이란 프로세스 속 채팅과 화상통화의 기능이 독립적으로 돌아가는것과\n같이 여러 기능을 수행할 수 있습니다.\n\n<br>\n\n### 프로세스와 스레드\n\n---\n\n스레드를 이해하기 위해서는 프로세스와 엮어서 설명하고자 합니다.\n전통적인 CPU는 하나의 프로세스만 처리할 수 있었습니다. 메모장, 워드, 게임등 많은 프로세스가 하나의 실행\n흐름을 가지고 한 번의 하나의 부분만 실행되는 프로세스입니다.\n\n![img.png](단일스레드 프로세스.png)\n\n이런 프로세스를 단일 스레드 프로세스라고 부릅니다.\n\n<br>\n\n하지만, 스레드라는 개념이 도입되면서 하나의 프로세스가 한 번에 여러가지 일을 동시에 처리하는 것이 가능해졌습니다.\n프로세스를 구성하는 명령어를 동시에 처리하는것이 가능해졌습니다.\n\n![img.png](멀티스레드 프로세스.png)\n\n<br>\n\n그림을 통해 스레드를 보게 되면 스레드는 '프로세스를 구성하는 실행의 흐름 단위'라고 표현 가능 할 것입니다.\n\n왜냐하면, 하나의 프로세스 안에 여러가지 스레드가 있고 각각의 작업 흐름을 가지며 프로세스가 하는 일을 병렬적으로 만들어\n주기 때문입니다.\n\n<br>\n<br>\n\n## 스레드 메모리 구조\n\n---\n\n![img.png](메모리구조.png)\n\n스레드의 메모리 구조를 이해하기 위해서는 이전 프로세서의 구조를 상기해봐야 합니다.\n\n프로세스는 스택, 힙, 데이터, 코드 영역을 각자 가진다고 합니다.\n스레드는 '프로세스를 구성하는 실행 흐름의 단위'라고 했고, 이 떄문에 스레드는 프로세스의 메모리 구조의 대부분을 공유해서\n사용한다. 그렇기 때문에 여러 스레드의 작업이 하나의 프로세스 안에서 이루어져도 동시작업이 가능한 이유입니다.\n\n<br>\n\n그렇다면 어떻게 스레드는 프로세스와 스레드간 데이터를 공유하는 것일까?\n아래 그림을 통해서 보게되면\n\n<br>\n\n![img.png](스레드자원공유.png)\n[사진출처](https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-os.html)\n\n<br>\n\n우선 하나의 프로세스안에 코드, 데이터, 힙, 스택 영역이 존재합니다. 그리고 프로세스 내부의 개별적인 스레드가 존재합니다.\n\n스레드가 레지스터, 프로그램 카운터, 스택을 개별적으로 가지는 핵심 이유는 독립적인 실행 흐름을 보장하기 위해서입니다.\n\n프로그램 카운터는 각 스레드가 서로 다른 코드 위치에서 실행될 수 있도록 현재 실행 지점을 개별 추적하고, \n\n레지스터는 각 스레드의 작업 데이터를 독립적으로 저장합니다. \n이를 통해 CPU가 스레드 간 전환할 때 현재 상태를 저장하고 복원하여 중단된 지점에서 정확히 재개할 수 있습니다.\n스택 영역을 따로 가지는 이유는 각 스레드가 독립적인 함수 호출 흐름을 가져야 하기 때문입니다. \n\n스택은 함수 호출 시 지역 변수, 매개변수, 리턴 주소를 저장하는데, 만약 스레드들이 스택을 공유한다면 한 스레드의 \n함수 호출이 다른 스레드의 함수 실행에 영향을 주어 실행 흐름이 꼬이게 됩니다. 따라서 각 스레드는 독립적인 스택을 가져 서로 다른 함수를 안전하게 호출하고 실행할 수 있습니다.\n결과적으로 이런 구조를 통해 스레드들은 힙과 데이터 영역은 공유하면서도 각자 독립적인 실행 흐름을 유지할 수 있어\n, 하나의 프로세스 내에서 여러 작업을 동시에 효율적으로 처리할 수 있게 됩니다.\n\n<br>\n<br>\n\n## TCB란\n\n---\n\n![img.png](TCB.png)\n\n스레드 제어 블록은 운영체제가 각 스레드를 관리하기 위해 유지하는 데이터 구조체입니다. \n프로세스 제어 블록(PCB)과 유사하지만 스레드 수준에서 필요한 정보들을 담고 있습니다.\n링크드 리스트 형태로 구현되어 PCB안에 해당 스레드의 TCB를 내포하고 있는 형태로 저장됩니다.\n\n<br>\n\n![img.png](TCB2.png)\n\n\n\n![img.png](TCB확장.png)\n\n\n<br>\n<br>\n\nTCB는 사진과 같은 형태로 저장되며, 아래와 같은 정보를 가진다.\n\n| 정보         | 설명                              |\n|------------|---------------------------------|\n| 스레드 식별자    | 각 스레드를 식별하는 고유한 식별자             |\n| 스레드 상태     | 실행 준비 대기 등 스레드의 현재 상태           |\n| 프로그램 카운터   | 스레드가 다음에 실행할 명령어의 주소            |\n| 레지스터       | 스레드가 현재 사용하고 있는 CPU 레지스터의 값을 저장 |\n| 스레드 우선순위   | 스케줄링 결정에 사용되는 스레드의 우선순위         |\n| 스레드 스택 포인터 | 스택 내에서 현재 작업의 위치를 가리키는 레지스터     |\n| 스레드 문맥 정보  | 문맥 교환 시 저장되고 복원되어야 할 정보         |\n\n\n\n\n\n\n\n"},{"excerpt":"문맥교환(Context Switching) 하나의 프로세스에서 다른 프로세스로 실행 순서가 넘어가면 어떤 일이 발생할까요? 프로세스 A가 CPU를 사용하다가 사용 시간이 끝나서 프로세스 B로 넘어간다면, A프로세스의 정보를\n저장하여야 합니다. 이곳에서는 이전에 보았던 PCB의 값인 레지스터 값, 메모리 정보등 중간 정보를 저장하여야\n이후 자신의 차례가 왔…","fields":{"slug":"/8/"},"frontmatter":{"date":"September 11, 2025","title":"8. 문맥교환 그리고 프로세스 상태 변화, 프로세스 계층과 생성 방식을 알아보기","tags":["운영체제"]},"rawMarkdownBody":"\n## 문맥교환(Context Switching)\n\n---\n하나의 프로세스에서 다른 프로세스로 실행 순서가 넘어가면 어떤 일이 발생할까요?\n\n프로세스 A가 CPU를 사용하다가 사용 시간이 끝나서 프로세스 B로 넘어간다면, A프로세스의 정보를\n저장하여야 합니다. 이곳에서는 이전에 보았던 PCB의 값인 레지스터 값, 메모리 정보등 중간 정보를 저장하여야\n이후 자신의 차례가 왔을 때 이 과정을 이어받아 작업을 수행할 수 있습니다.\n\n여기서 하나의 프로세스를 실행하기 위해 필요한 정보들을 문맥(Context)라고 부르게 됩니다.\n이러한 문맥값들은 PCB속에 저장됩니다.환\n\n<br>\n\n![img.png](문맥교환.png)\n[사진출처](https://yoongrammer.tistory.com/53)\n\n결국 프로세스 A에서 B로 프로세스가 넘어가는 순간에 프로세스 A정보를 백업하고 그작업이 끝난다면\n프로세스 B의 문맥을 불러오게 되며 이 것이 프로세스를 교대하는 방법입니다.\n\n문맥교환을 통해 여러개의 프로세스가 병렬적으로 시행되는 것 처럼 보이게 하지만 이러한 문맥교환은\n오버헤드가 발생할 수 있기 때문에 문맥교환이 자주일어나면 오버헤드를 신경써야 합니다.\n\n<br>\n<br>\n\n## 프로세스 상태\n\n---\n\n이전에 PCB에 기록되는 정보 중 프로세스 상태가 있다고 합니다. 여기서 말하는 프로세스 상태는 생성이 되었는지\n혹은 CPU를 사용하는지와 같은 정보를 통칭해서 프로세스 상태라고 부르게 됩니다.\n\n<br>\n\n프로세스 상태는 크게 다섯가지로 나뉠 수 있습니다.\n\n![img.png](프로세스 상태 전이도.png)\n[사진출처](https://thebook.io/080367/0021/)\n\n<br>\n\n### 1. 생성 상태\n\n프로세스를 생성 중인 상태를 생성 상태라고 부릅니다. 메모리에 적재되어 PCB를 할당받은 상태를 생성상태라고 부르게 됩니다.\n생성 상태가 끝난다고 곧바로 실행되는 것이 아닌 준비 상태가 되어 실행되기를 기다리게 됩니다.\n\n<br>\n\n### 2. 준비 상태\n\n준비 상태는 당장 CPU를 할당받아 실행될 수 있지만, 차례가 오지않아 기다리고 있는 상태입니다.\n이 상태에서 준비가 되면 실행 상태로 넘어 갑니다. 그리고 다른 상태에서 다시 준비 상태로도 전환이 가능합니다.\n\n준비 상태인 프로세스를 실행 상태로 전환하는 것을 디스패치 라고 부릅니다.\n\n<br>\n\n### 3. 실행 상태\n\n실행 상태는 CPU를 할당받아 실행 중인 상태를 지칭 합니다. 실행 상태인 프로세스는 할당된 시간 동안 CPU를 사용할 수 있습니다.\n이때 제한된 시간내 프로세스를 완료하지 못한경우 준비 상태로 전환이 되며, I/O입력처럼 대기해야 하는 상황이 생기면\n대기 상태로 넘어가게 됩니다.\n\n<br>\n\n### 4. 대기 상태\n\n실행 상태에서 I/O입력과 같이 프로세스가 대기해야 하는 상황이 온다면 대기 상태로 진입하게 됩니다.\n대기 상태가 끝난다고 해도 실행 상태가 되는것이 아닌 준비 상태로 넘어가게 됩니다.\n\n<br>\n\n### 5. 종료 상태\n\n프로세스가 종료된 상태입니다. 이 상태에 도달하면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리합니다.\n\n<br>\n<br>\n\n## 프로세스 계층 구조\n\n---\n\n프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있습니다.\n\n이때 새 프로세스를 생성한 프로세스를 부모 프로세스라고 부르게 되며, 생성 된 프로세스를 자식 프로세스라고\n부르게 됩니다.\n부모의 프로세스와 자식의 프로세스는 각각 고유한 PID를 가지며 자식프로세스에서 부모프로세스 PID를 PPID로 가지고 있기도 합니다.\n\n<br>\n\n![img.png](프로세스 계층 구조.png)\n[사진 출처: 혼자 공부하는 운영체제 저자:강민철]\n\n<br>\n<br>\n\n## 프로세스 생성기법\n\n---\n\n그렇다면 부모 프로세스가 어떻게 자식 프로세스를 생성 할까요?\n\n그 방법은 fork, exec라는 명령어를 통해서 생성하게 됩니다.\n\n부모 프로세스는 fork를 통해 자신의 복사본을 자식 프로세스로 생성해내고, 그 복사본은 exec명령어를 통해\n자신의 메모리 공간을 다른 프로그램으로 교체합니다.\n\n<br>\n\n![img.png](fork.png)\n\n<br>\n\n좀더 자세히 설명하면 fork, exec 모두 시스템 호출로 분류 됩니다.\n부모 프로세스는 fork 시스템 호출을 통해 자신의 복사본을 자식으로써 생성합니다.\n\n여기서 자식은 부모의 복사본이기 때문에 부모 프로세스의 자원들, 예를들면 메모리의 내용, 열린 파일의 목록등을\n상속하게 됩니다. 그렇다고 해서 모든 정보가 같지는 않습니다.\n\n왜냐하면, PID나 메모리 저장구조는 고유한 정보이기 때문에 fork로 만들어진 자식은 PID, 메모리 저장위치\n처럼 고유한 정보에 대해서는 개별적인 값을 가지고 있습니다.\n\n<br>\n\n![img.png](exec.png)\n\n<br>\n\nfork만 사용한 프로세스는 완전한 자식 프로세스라고 명하기는 조금 어렵습니다.\nPID와 같은 고유한 값을 제외한다면 부모가 가진 리소스를 동일하게 사용하는 대체품이기 때문입니다.\n\n그렇기 때문에 자식 프로세스는 자신의 프로세스를 가지기 위해 exec 시스템 호출을 하게 됩니다.\n\nexec 호출을 진행하게 되면 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰게 됩니다.\n\n코드 영역과 데이터 영역의 내용이 실행한 프로그램으로 바뀌게 되고, 나머지 영역은 초기화 됩니다.\n\n"},{"excerpt":"프로세스란 무엇일까? 우리는 흔히 보조 기억장치에 있는 프로그램 정보를 메모리로 적재하고, 적재된 정보를 CPU가 읽어 사용하는 이 과정을 프로그램이 실행되었다 라고 표현합니다. 여기서 실행된 프로그램을 프로세스라는 개별적인 용어로 부르고 프로그램을 실행하는 과정을 프로세스를 생성한다고 표현합니다. ![img.png](실행중인 프로세스.png) 백그라운드…","fields":{"slug":"/7/"},"frontmatter":{"date":"September 10, 2025","title":"7. 프로세스와 PCB 그리고 메모리 구조에 대해서 알아보기","tags":["운영체제"]},"rawMarkdownBody":"\n## 프로세스란 무엇일까?\n\n---\n\n우리는 흔히 보조 기억장치에 있는 프로그램 정보를 메모리로 적재하고, 적재된 정보를 CPU가 읽어 사용하는 이 과정을 프로그램이 실행되었다 라고 표현합니다.\n\n여기서 실행된 프로그램을 **프로세스**라는 개별적인 용어로 부르고 프로그램을 실행하는 과정을 프로세스를 생성한다고 표현합니다.\n\n<br>\n<br>\n\n![img.png](실행중인 프로세스.png)\n\n<br>\n위 사진처럼 보이는 것보다 더 많은 프로세스가 작동하고 있는데, 여기서 사용자가 볼 수 있는 프로세스를 포그라운드 프로세스 라며 명하며,\n보이지 않는 프로세스를 백그라운드 프로세스라고 부르게 됩니다. \n\n백그라운드 프로세스라고 해서 사용자와 상호작용하지 않는 다는 뜻은 아닌데 백그라운드 프로세스 중에서 사용자와 상호작용 하지 않고 자신의 일만을 수행하기 위해 존재하는\n프로세스를 **데몬(daemon)** 프로세스라고 명합니다.\n\n<br>\n\n## 프로세스 제어 블록(PCB)\n\n---\n\nCPU자원이 한정되어 있는 반면에, 모든 프로세스는 실행을 위해 CPU를 사용하여야 합니다. \n그렇기 떄문에 프로세스들은 한정된 시간 만 CPU를 사용하며 자신의 차례를 기다립니다.\n\n운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU와 여러가지 자원을 배분합니다.\n이를 위해 운영체제는 프로세스 제어 블록(PCB)를 이용합니다.\n\n<br>\n\nPCB는 커널 영역에 생성되고, 수많은 프로세스를 PCB를 통해 태그처럼 사용해 특정 프로세스를 식별하며 해당 프로세스를 처리하는데 필요한 정보를 판단합니다.\n\n즉, 가게 주인이 물건을 태그를 통해 판단하고 가격을 알 수 있고, 생산지를 알 수 있는 것처럼 PCB는 운영체제가 수 많은 프로세스를 식별하고 그 프로세스의 정보를 판단하게 돕습니다.\n\n<br>\n<br>\n\n## PCB의 구조\n\n---\n\n<br>\n\n![img.png](PCB.png)\n\n[사진 출처](https://binaryterms.com/process-control-block-pcb.html)\n\n<br>\n\n위 그림처럼 PCB는 프로세스를 식별하기 위해 여러가지 정보를 담고 있습니다. 프로세스의 ID나, \n레지스터의 값 혹은 상태같이 많은 정보를 담고있으며 이를 알아보고자 합니다.\n\n<br>\n\n### 프로세스 ID\n\n![img.png](프로세스ID.png)\n\n프로세스 ID(PID)는 프로세스를 식별하기 위해 존재하는 고유 ID입니다. 메모장을 두개 킨다고 할지라도 다른 프로세스ID가\n만들어지는 것처럼 중복된 활동이여도 하나의 프로세스는 고유한 ID를 가지게 됩니다.\n\n<br>\n\n### 레지스터 값\n\n프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원합니다.\n여기에는 프로그램 카운터가 속하게 됩니다.\n\n<br>\n\n### 프로세스 상태\n\n현재 프로세스가 어떤 상태인 기록합니다. 입출력장치를 사용하기 위해 기다리는지 혹은 CPU를 사용하고 있는 상태인지 와 같은\n상태를 기록하며 자세한 상태는 다음장에서 설명합니다.\n\n<br>\n\n### CPU 스케줄링 정보\n\n프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보도 PCB에 기록됩니다.\n\n<br>\n\n### 메모리 관리 정보\n\n프로세스마다 메모리에 저장된 위치가 다릅니다. 그렇기 떄문에 PCB에는 해당 프로세스가 저장된 메모리 위치를 기록해야 합니다.\n\n<br>\n<br>\n\n## 프로세스의 메모리 영역\n\n---\n\n프로세스가 생성되면 커널 영역에 PCB가 생성됩니다. 그렇다면 커널 영역이 아닌 사용자 영역에는 어떤 데이터가 들어갈까요?\n\n\n![img.png](메모리구조.png)\n\n[사진출처](https://www.programmersought.com/article/98613694619/)\n\n위 그림처럼 하나의 프로세스는 크게 코드영역(Text), 데이터 영역(Bss,Gvar), 힙 영역(Heap), 스택 영역(Stack) 4가지로 나뉩니다.\n\n차례대로 설명하자면,\n\n<br>\n<br>\n\n### 코드영역 or 텍스트영역(Text)\n\n이곳에는 실행할 수 있는 기계어로 이루어진 명령어가 저장됩니다. 가공할 수 있는 데이터가 아닌\nCPU가 실행해야 하는 명령어가 담겨있기 때문에 읽기모드만 지원합니다.\n\n<br>\n\n### 데이터 영역\n\n프로그램을 실행하는 동안 유지되어야 하는 데이터가 저장되는 공간입니다. 대표적은 전역 변수가 이곳에 해당합니다.\n\n<br>\n\n### 코드영역 & 데이터 영역 공통점\n\n위 두 영역은 크기가 변하지 않습니다. 프로그램을 구성하는 명령어가 작동중에 코드 양이 늘어나는 경우가 없으니\n이 두가지 영역을 정적 할당 영역이라고 부릅니다.\n\n<br>\n\n### 힙 영역\n\n프로그래머가 직접 할당할 수 있는 공간입니다. 프로그래밍 과정에서 힙 영역에 데이터를 할당했다면 언젠가는 이 영역에 \n데이터를 반환해야 합니다. 그렇지 않다면 메모리 용량은 점점 줄어들어 장애가 발생할 수 있습니다.\n\n이런 문제를 메모리를 할당받고 해제 하지 않았다고 하여 누수가 발생했다. 즉 메모리 누수라고 부릅니다.\n\n<br>\n\n### 스택 영역\n\n스택 영역은 데이터를 일시적으로 저장하는 공간입니다.\n데이터 영역에 담기는 값과는 다르게 잠깐 쓸 데이터를 담아두는 공간입니다.\n함수를 실행하는 동안 필요한 지역변수, 매개 변수가 이곳에 해당합니다.\n그렇기 떄문에 함수가 종료되면 스택 영역에서 해당 함수에 쓰였던 변수들도 같이 없어지게 됩니다.\n\n<br>\n<br>\n\n### 힙 영역 & 스택 영역 공통점\n\n위 두 영역은 실시간으로 그 크기가 변할 수 있고 그렇기 떄문에 동적 할당 영역이라고 부르게 됩니다.\n\n그림을 보면 unused memory영역이 있는데, 스택 영역과 힙 영역이 동적이기 떄문에 힙은 아래에서 위로, 스택은 \n위에서 아래로 주소를 할당하게 됩니다. 그렇게 되면 서로 충돌없이 동적으로 값을 할당할 수 있기 때문입니다.\n\n여기서 만약에 힙이나 스택에 많은 정보가 담겨서 서로의 지점을 충돌 할 수 있는데, 그럴때 각각 stack overflow,\nheap overflow라고 부르게 됩니다.\n\n\n\n\n\n"},{"excerpt":"IO란 개발을 하다 보면 I/O라는 용어를 자주 듣게 됩니다. I/O는 Input/Output의 줄임말로, 컴퓨터가 외부와 데이터를\n주고받는 일련의 작업을 통칭 I/O라고 부르게 됩니다. 예시를 들어서 파일 읽기/쓰기 (문서를 열거나 저장하는 행위) 네트워크 통신(웹사이트 접속, 이메일 전송) 데이터베이스 조회(회원 정보 검색) 이런 일련의 행위는 공통적…","fields":{"slug":"/6/"},"frontmatter":{"date":"September 09, 2025","title":"6. 동기식/비동기식 I/O의 차이와 활용 사례","tags":["운영체제"]},"rawMarkdownBody":"\n## IO란\n\n개발을 하다 보면 I/O라는 용어를 자주 듣게 됩니다. I/O는 Input/Output의 줄임말로, 컴퓨터가 외부와 데이터를\n주고받는 일련의 작업을 통칭 I/O라고 부르게 됩니다.\n\n예시를 들어서\n\n- 파일 읽기/쓰기 (문서를 열거나 저장하는 행위)\n- 네트워크 통신(웹사이트 접속, 이메일 전송)\n- 데이터베이스 조회(회원 정보 검색)\n\n이런 일련의 행위는 공통적인 특징이 있는데, 물리적인 시간이 걸린다는 점입니다.\n그렇기 떄문에 IO를 어떻게 다룰까에 대한 방법또한 여러가지 존재합니다.\n\n<br>\n<br>\n\n## 동기와 비동기란\n\nIO를 다루는 방법에는 동기, 비동기에 대한 개념이 등장합니다.\n이러한 개념을 사전에 정의 하고 내려가겠습니다.\n\n### 동기 (Synchronous)\n\n프로그램에서 말하는 동기란 하나의 작업에 대해서 요청과 응답 과정을 기다리는 행위입니다.\n예를들어, WAS가 데이터베이스에 조회 요청을 하고 데이터베이스는 요청받은 데이터를 돌려줄것입니다.\n이 과정에서 WAS는 요청직후 부터 응답을 받을때 까지 과정에서 데이터베이스의 응답을 기다리게 됩니다. 이것이 동기입니다.\n\n<br>\n\n### 동기의 특징\n\n순차적 실행: 한 작업이 완료되어야 다음 작업이 시작\n블로킹: 현재 작업이 끝날 때까지 다른 작업은 대기\n예측 가능: 코드가 위에서 아래로 순서대로 실행\n\n<br>\n<br>\n\n### 비동기 (Asynchronous)\n\n그렇다면 비동기는 하나의 작업에 대해서 요청과 응답 과정을 기다리지 않는 행위입니다.\n예를들어, WAS가 데이터베이스에 조회 요청을 하게 되면 데이터베이스가 이를 수행하고 응답할것입니다.\n이 과정 사이에 시간동안 WAS는 본인의 다른 작업을 수행하다가 데이터베이스의 응답을 받게 됩니다.\n즉 요청과 응답 사이 기간동안 WAS는 본인의 일을 하며 무작정 기다리지 않는 것입니다.\n\n<br>\n\n### 비동기의 특징\n\n동시 실행: 여러 작업을 동시에 시작 가능\n논블로킹: 작업 완료를 기다리지 않고 다른 작업 진행\n콜백/Promise: 작업 완료 시 결과를 알려주는 방식\n\n<br>\n\n## 동기식 I/O\n\n![img.png](동기식IO.png)\n\n<br>\n\n동기식IO는 IO요청이 발생하였을 때 이전 동기 설명처럼 IO요청이 끝날때 까지 기다리는 방식입니다.\n프로그램이 IO작업을 요청하게 되면, 다른 동작을 수행하지 않고 멈춰서 IO작업이 리턴되기 까지 기다립니다.\nI/O작업이 완료되면 인터럽트를 통해 완료를 알리게 됩니다. 이후 CPU 제어권이 기존 프로그램에게 넘어가게 됩니다.\n\n이러한 방식의 특징은 구현이 쉽다는 특징이 있지만, 연산에 대한 기다림으로 인해 자원 낭비를 하는 특징이 있습니다.\n\n## 비동기식 I/O\n\n![img.png](비동기식IO.png)\n\n비동기식IO는 IO요청이 발생하였을 떄 이전 비동기 설명처럼 IO요청을 기다리지 않는 방식입니다.\n프로그램이 IO 작업을 요청하고, 그 작업이 완료되기를 기다리지 않고 즉시 다음 작업으로 넘어가는 방식입니다.\n\n이러한 방식의 특징은 구현의 복잡성이 높다는 것이지만, 대용량 데이터를 처리하는데 여러 IO작업을 동시에 처리해야 할 떄 유용합니다.\n"},{"excerpt":"인터럽트 기반 입출력 인터럽트는 컴퓨터 시스템에서 현재 실행 중인 프로세스를 중단 하고, 인터럽트를 발생시킨 작업을 처리하기 위한\n방법 혹은 과정 이다. 인터럽트는 CPU의 실행 흐름을 중단시키고 인터럽트가 끝난 후 원래의 흐름으로 돌아가는 방식을 가진다. 인터럽트는 크게 두가지로 나뉘게 되며, 소프트웨어 혹은 하드웨어 인터럽트로 나누어지며 이는 인터럽트…","fields":{"slug":"/5/"},"frontmatter":{"date":"September 08, 2025","title":"5. 인터럽트와 DMA를 통한 효율적 입출력 처리","tags":["운영체제"]},"rawMarkdownBody":"\n## 인터럽트 기반 입출력\n\n---\n\n인터럽트는 컴퓨터 시스템에서 현재 실행 중인 프로세스를 중단 하고, 인터럽트를 발생시킨 작업을 처리하기 위한\n방법 혹은 과정 이다. 인터럽트는 CPU의 실행 흐름을 중단시키고 인터럽트가 끝난 후 원래의 흐름으로 돌아가는 방식을 가진다.\n\n인터럽트는 크게 두가지로 나뉘게 되며, 소프트웨어 혹은 하드웨어 인터럽트로 나누어지며 이는 인터럽트를 발생시킨\n주체가 무엇인가에 따라 나뉘게 된다.\n\n대표적인 하드웨어 인터럽트는 I/O완료, 대표적인 소프트웨어 인터럽트는 시스템 콜이 있다.\n\n<br>\n<br>\n\n![img.png](Interrupts.png)\n\n이러한 인터럽트 기반 입출력의 순서를 설명하자면\n\n1. CPU가 입출력 장치에 대해 입출력 요청을 보낸다.\n2. CPU는 요청이후 다른 작업을 수행한다.\n3. 입출력 장치가 준비되면 인터럽트를 발생시킨다.\n4. CPU는 현재 실행 중인 작업을 중단하고 인터럽트 서비스 루틴(ISR)을 실행한다.\n5. 데이터를 처리한 후 , CPU는 원래 수행하던 작업을 계속 실행한다.\n\n이러한 인터럽트 기반 입출력의 단점은 인터럽트가 많이 발생하는 상황에서 CPU가 부하될 수 있다는 단점이 있다.\n\n\n<br>\n<br>\n\n## DMA(Direct Memory Access 직접 메모리 접근)\n\n---\n\nDMA방식은 이름에서 볼 수 있듯이 CPU를 사용하지 않고 입출력 장치가 직접 메로리와 데이터를 교환합니다.\n\n이것이 가능한 이유는 DMA 컨트롤러가 존재해, 메모리와 입출력 장치 사이의 데이터를 관리하기 때문입니다.\n\nDMA에서는 CPU가 전송할 데이터의 위치, 포인터, 바이트 크기만 DMA 컨트롤러에 전달하면, \nDMA가 입출력 작업을 대신 처리하고 전체 작업이 완료될 때만 CPU에 인터럽트를 보냅니다. \n이로 인해 CPU와 여러 입출력 장치가 직접 연결되던 기존 구조에서 CPU-DMA-입출력 장치 구조로 변화했고,\nCPU의 가용 시간이 현저히 증가하는 효과를 얻었습니다. \n이는 교수가 조교에게 학생 관리를 맡기고 최종 결과만 확인하는 것에 비유할 수 있으며, \n현재 DMA는 많은 컴퓨터 장치에서 보편적으로 사용되는 기술이 되었습니다.\n\n<br>\n<br>\n\n![img.png](DMA.png)\n\n<br>\nDMA 방식을 순서로 설명하자면\n\n1. CPU가 DMA 컨트롤러에게 입출력 요청합니다.\n2. DMA 컨트롤러가 메모리와 입출력 장치 간의 데이터 전송을 직접 수행합니다.\n3. 데이터 전송이 완료되면 DMA 컨트롤러가 인터럽트를 발생 시켜 CPU에게 완료를 알립니다.\n4. CPU는 인터럽트를 받아서 필요한 후처리 수행합니다.\n\n\n"},{"excerpt":"단일 프로세스 초창기 컴퓨터를 상상하면 지금처럼 복잡한 방법이 아닌, 한번에 하나의 프로그램만 실행 할 수 있었을것이다.\n이 말은 다른 프로그램을 사용 해야 하는 순간 기존 프로그램이 종료 되거나,\n끝날때 까지 기다려야 합니다.  멀티 프로그래밍  이러한 문제를 해결하기 위해 어쩔 수 없이 작업이 멈추는 구간에 다른 작업을 진행하는 방법을 사용하게 된다.…","fields":{"slug":"/4/"},"frontmatter":{"date":"September 07, 2025","title":"4. 멀티프로그래밍, 시분할 시스템, 멀티프로세싱 개념","tags":["운영체제"]},"rawMarkdownBody":"\n## 단일 프로세스\n\n---\n\n초창기 컴퓨터를 상상하면 지금처럼 복잡한 방법이 아닌, 한번에 하나의 프로그램만 실행 할 수 있었을것이다.\n이 말은 다른 프로그램을 사용 해야 하는 순간 기존 프로그램이 종료 되거나,\n끝날때 까지 기다려야 합니다.\n\n<br>\n\n![img.png](단일프로세스.png)\n\n<br>\nCPU 관점에서 본다면 특정 작업을 수행중 IO 작업이 생긴다면 IO작업동안 CPU는 멈추게\n될것이고 그 상황에서 CPU가 놀고 있게 되는 시간이 늘어나는 것입니다.\n\n<br>\n\n## 멀티 프로그래밍\n\n![img.png](멀티프로그래밍.png)\n\n이러한 문제를 해결하기 위해 어쩔 수 없이 작업이 멈추는 구간에 다른 작업을 진행하는 방법을 사용하게 된다.\n이를 멀티 프로그래밍이라고 부르며 그림처럼 CPU 사용률을 높이기 위한 목적이었습니다.\n\n하지만 이러한 방식의 문제는 앞선 프로세스가 길어질 수록 즉 IO사용처럼 비는 시간없이 순수하게 많은 시간을\n쓰게 된다면 이후 프로세스가 계속 기다려야 하는 문제가 있었습니다.\n\n<br>\n\n## 멀티 태스킹\n\n![img.png](멀티태스킹.png)\n\n멀티 프로그래밍 방식에서 더 나아가 모든 프로세스가 공정하게 특정 짧은 시간만 실행되게 반복한다면 길게 시행되는\n프로세스 뒤에 오는 프로세스가 기다리는 문제가 없을 것이다. 이것이 멀티태스킹을 사용하는 이유입니다.\n\n**프로세스1**에서 **프로세스2**로 작업을 스위칭 하는것을 문맥 교환(Context Switching)이라고\n부르게 되는데 이러한 문맥교환은 값싼 작업이 아니고 이러한 작업이 자주 일어나게 된다면 비효율 적인 단점이 부각되다 보니\n새로운 방식을 사용하게 됩니다.\n\n<br>\n\n## 멀티 프로세싱\n\n멀티 프로세싱이란 이전 멀티 태스킹과 이름은 비슷 하지만 완전히 다른 방식입니다.\n\n이전 방식은 하나의 **CPU**를 어떻게 쪼개서 사용할까라는 목적이였다면, **멀티 프로세싱**은 **CPU** 작업단위인\n코어 자체를 늘려서 여러 CPU코어가 동시에 작업하는것을 멀티 프로세싱이라고 부르게 됩니다.\n\n![img.png](멀티프로세싱.png)\n\n멀티 프로세싱은 CPU코어 수를 늘리는 방법이기 때문에, 이를 어떻게 처리할까에 대한 내용은 멀티 프로세싱 자체의 내용이 아니고 앞서 나왔던 방법론을 도입할 수 있습니다.\n그림처럼 하나의 프로세스를 여러 코어가 담당하는 방법이나, 여러 프로세스를 여러 코어가 담당 할 수 도 있습니다.\n\n### 출처\n[사진출처](https://medium.com/@ashappyasiknow/single-process-system-multi-programming-multitasking-%EC%9D%B4%EB%9E%80-9f9b65ec0311)\n"},{"excerpt":"이중모드 운영체제는 자원을 충돌 없이 효율적으로 사용하기 위해 자원 관리의 진입점이 된다고 말했습니다. 그럼 일반 응용프로그램은 어떻게 자원에 접근 할 수 있을까요? 이에 대한 답은 이중 모드 입니다.  위 사진 처럼 CPU가 명령을 실행하는 방식을 사용자 모드 와 커널 모드로 나누어 사용하게 됩니다. 사용자 모드 사용자 모드는 운영체제 서비스를 제공받을…","fields":{"slug":"/3/"},"frontmatter":{"date":"September 06, 2025","title":"3. 유저모드와 커널모드 전환, 시스템 콜의 동작 원리","tags":["운영체제"]},"rawMarkdownBody":"\n## 이중모드\n\n---\n\n운영체제는 자원을 충돌 없이 효율적으로 사용하기 위해 자원 관리의 진입점이 된다고 말했습니다.\n\n> 그럼 일반 응용프로그램은 어떻게 자원에 접근 할 수 있을까요?\n\n이에 대한 답은 **이중 모드** 입니다.\n\n<br>\n\n\n![img.png](이중모드.png)\n\n<br>\n\n위 사진 처럼 **CPU**가 명령을 실행하는 방식을 **사용자 모드** 와 **커널 모드**로 나누어 사용하게 됩니다.\n\n<br>\n\n### 사용자 모드\n\n사용자 모드는 운영체제 서비스를 제공받을 수 없는 실행 모드입니다.\n</br> CPU가 해당 모드인 경우, 입출력 명령어와 같은 하드웨어 자원 접근 명령을 실행할 수 없습니다. 일반 프로그램은 기본적으로 사용자 모드로 실행됩니다.\n\n<br>\n\n### 커널 모드\n커널모드는 운영체제 서비스를 제공받을 수 있는 실행 모드로 커널 영역의 코드를 실행할 수 있습니다.\n</br> CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 명령어를 비롯한 모든 명령어를 실행할 수 있으며, 운영체제는 커널 모드로 실행됩니다.\n\n<br>\n\n요약 하자면 일반 응용프로그램은 평소에 **사용자 모드**를 통해서 실행 되다가 실제 운영체제의 코드를 실행하여야 하는 순간이 오면 **커널 모드**로 전환하여 실행하다가\n운영체제의 코드 실행 지점이 끝난다면 다시 **사용자 모드**로 전환되게 됩니다.\n\n이러한 방식으로 자원을 **운영 체제**로 하여금 독자적으로 관리할 수 있게 합니다.\n\n<br>\n\n> 사용자 모드에서 어떻게 커널모드로 전환할까?\n\n사용자 모드에서 커널모드로 전환하는 방식은 **시스템 콜**에 의해서 발생합니다.\n\n<br>\n\n![img.png](시스템콜.png)\n\n<br>\n\n그림처럼 사용자 모드로 실행되는 프로그램이 자원에 접근해야 할때 운영체제에 커널 모드로 요청을 보내게 되고 이것을 **시스템 콜**이라고 부르게 됩니다.\n\n**시스템 호출**은 **소프트 웨어 인터럽트**에 속합니다. 이러한 특징 때문에 **CPU**가 **시스템 호출**을 처리하는 순서가 **인터럽트 처리 순서**와 비슷합니다.\n\n**시스템 호출**이 발생하면 **지금까지의 작업을 백업** 하고, 커널 영역 내의 호출 하여야 하는 코드를 실행 한 뒤 다시 돌아와 기존 프로그램을 계속 실행합니다.\n\n<br>\n\n![img.png](시스템콜작동방식.png)\n\n<br>\n\n그림을 통해서 이해를 하게 되면,\n\n1. 응용 프로그램은 일반적인 작업을 수행중 운영체제 코드를 실행 하여야 하는 작업에 도달하게 됩니다.\n2. 그러면 응용프로그램은 운영체제에게 자원 접근에 대한 시스템 콜을 날리게 된다.\n3. 현재 작업을 백업하게 됩니다.\n4. 이후 응용프로그램은 운영체제의 코드를 실행합니다.\n5. 작업이 끝나면 다시 사용자 영역으로 돌아와 멈춰둔 작업을 진행합니다.\n\n이런 세부적인 순서를 진행하게 됩니다.\n\n### 출처\n[사진출처](https://hongong.hanbit.co.kr/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80-%EC%BB%A4%EB%84%90%EC%9D%98-%EA%B0%9C%EB%85%90-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EC%9D%84-%EC%9C%84%ED%95%9C/)\n\n"},{"excerpt":"CPU 스케줄링 CPU 스케줄링은 CPU를 항상 바쁘게 동작시켜 자원을 낭비하지 않고 최적으로 활용할 수 있게 돕기도 하며,\n모든 프로세스로 하여금 CPU를 공정하게 할당할 수 있게 합니다. CPU 스케줄링이란 프로세스의 작업을 수행하기 위해 언제, 어떤 프로세스에 CPU를 할당할지 결정하는 작업을 말합니다.\n CPU 스케줄링 원칙 CPU는 스케줄링을 하…","fields":{"slug":"/2/"},"frontmatter":{"date":"September 05, 2025","title":"2. CPU 스케줄링, 시스템 자원 관리","tags":["운영체제"]},"rawMarkdownBody":"\n## CPU 스케줄링\n\n---\n\n**CPU 스케줄링**은 CPU를 항상 바쁘게 동작시켜 자원을 낭비하지 않고 최적으로 활용할 수 있게 돕기도 하며, \n<br>모든 프로세스로 하여금 CPU를 공정하게 할당할 수 있게 합니다.\n\nCPU 스케줄링이란 프로세스의 작업을 수행하기 위해 언제, 어떤 프로세스에 CPU를 할당할지 결정하는 작업을 말합니다.\n<br>\n\n### CPU 스케줄링 원칙\n\n---\n\nCPU는 스케줄링을 하면서 두가지 원칙을 중요시 하게 됩니다.\n<br>\n\n1. 공정함: 특정 프로세스 실행이 무한정 대기하지 않도록 기간을 보장합니다.\n2. 우선순위: 우선순위가 높은 작업에 우선권을 제공 합니다.\n\n<br>\n\n### CPU 스케줄링 평가 기준\n\n---\n\nCPU는 객관적인 스케줄링을 위해 아래와 같은 평가 기준을 사용합니다.\n\n<br>\n\n1. CPU 사용률 - CPU가 작업을 수행하는데 사용하는 시간의 비율\n2. 처리량 - 시스템이 단위 시간당 완료할 수 있는 작업의 양\n3. 응답 시간 - 시스템이 사용자의 요청에 반응하여 첫 번째 응답을 생성하기 시작하는데 걸리는 시간\n4. 대기 시간 - 프로세스가 실행되기 위해 CPU를 할당받아 준비 상태에서 대기하는 시간의 총합\n5. 처리 시간 - 특정 작업이 시작되었을 때부터 그 작업이 완전히 끝나는데 걸리는 시간의 총합\n\n"},{"excerpt":"운영체제란 무엇일까? 운영체제는 컴퓨터 하드웨어와 소프트웨어를 관리하고, 사용자와 컴퓨터 사이 인터페이스 역할을 합니다. 대표적인 기능으로는 자원을 관리하고,\n 프로세스를 관리하는 등 여러가지 일을 수행합니다. 이러한 운영체제는 프로그램을 위한 프로그램으로서 작동하게 되며, 여러 프로그램을 충돌없이 효율적으로 사용하는 기능을 제공합니다. 운영체제의 역할 …","fields":{"slug":"/1/"},"frontmatter":{"date":"September 04, 2025","title":"1. 운영체제의 역할과 커널의 기능","tags":["운영체제"]},"rawMarkdownBody":"\n## 운영체제란 무엇일까?\n\n---\n\n**운영체제**는 컴퓨터 하드웨어와 소프트웨어를 관리하고, 사용자와 컴퓨터 사이 인터페이스 역할을 합니다. 대표적인 기능으로는 **자원**을 **관리**하고, \n</br> 프로세스를 관리하는 등 여러가지 일을 수행합니다.\n\n이러한 **운영체제**는 프로그램을 위한 프로그램으로서 작동하게 되며, 여러 프로그램을 충돌없이 효율적으로 사용하는 기능을 제공합니다.\n\n\n## 운영체제의 역할\n\n---\n\n### 하드웨어 관리\n\n> 운영체제는 CPU, 메모리, 입출력 장치 등 컴퓨터 하드웨어 자원을 관리합니다.\n> </br> 여기서 말하는 **관리**란 자원의 충돌을 방지하고 사용자가 하드웨어를 **효율**적으로\n> 사용하도록 처리하는것을 의미하게 됩니다.\n\n<br>\n<br>\n\n### 프로세스 관리\n\n> 프로세스의 생성과 종료 그리고 CPU 스케줄링을 통해 프로세스의 실행 시간을 관리합니다. \n> </br> **멀티 태스킹**환경에서 프로세스 전환을 관리합니다.\n\n<br>\n<br>\n\n### 메모리 관리\n\n> 각 애플리케이션에 충분한 메모리 공간을 할당하는 기능을 합니다.\n> </br> 또한 가상 메모리를 통해 실제 메모리보다 큰 주소 공간을 제공합니다.\n\n## 커널이란 무엇일까?\n\n---\n\n**커널**이란 운영체제의 핵심 기능을 담당하며, 커널은 하드웨어와 소프트웨어 애플리케이션 간 통신을 관리합니다. 커널의 대표적인 기능으로는 \n</br> **프로세스 관리**, **메모리 관리**, **파일 시스템**, **입 출력 관리**의 역할을 수행하게 됩니다.\n\n위 설명 처럼 **운영체제**의 핵심기능을 **커널**이 많은 부분을 담당하기 때문에 이전에 설명한 운영체제의 기능이 **커널**의 기능이라고 생각하면 됩니다.\n\n\n## 커널이 자원을 관리하는 이유\n\n---\n\n> **커널**은 어떻게 충돌 없이 자원을 관리할까요?\n\n이 질문에 대한 대답은 자원을 관리하는 지점을 **커널**을 통한 단일 진입점으로 만들게 되면서 해결 하게 됩니다.\n<br>\n\n> 왜 자원을 **커널**을 통해서만 관리하게 설게 했을까요? \n\n**커널**이 자원을 혼자 관리해야 하는 이유를 예시를 들어서 설명하겠습니다.\n\n유치원 수업시간에 하나의 바구니에 **테이프**, **연필**, **지우개**와 같은 문구용품을 담아두고 선생님이 학생들에게 자율적으로 사용해도 된다고 하게 된다면 어떤일이 벌어질까요?\n\n처음에는 아이들이 각자 필요한 문구 용품을 사용하겠지만 얼마 가지 않아서 **연필**을 찾는 학생,\n</br> **테이프**를 가지고 누가먼저 쓸지 싸우는 학생,\n</br> 혹은 **지우개**를 망가뜨린 학생등 많은 사고가 있을 것입니다.\n\n이러한 문제가 벌어지는 이유는 공용 문구를 사용할때 **통제권**이 모두에게 있기 떄문입니다. 그렇다면 이를 해결하기 위해서\n모두에게 있는 **통제권**을 하나로 합쳐서 해결하면 되는 문제이고 이것이 자원을 사용하기 위해 **커널의 관리**를 받아야 하는 이유입니다.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}